import streamlit as st
import os
import sqlite3
from datetime import datetime
from dotenv import load_dotenv
from pydub import AudioSegment
import tempfile
import wave
import numpy as np
import queue
import threading
import docx
from io import BytesIO
import secrets
import smtplib
from email.mime.text import MIMEText
import streamlit.web.bootstrap
from authlib.integrations.requests_client import OAuth2Session
import requests
from av import AudioFrame
import time
from b2sdk.v2 import InMemoryAccountInfo, B2Api
import bcrypt
from io import BytesIO
import json
from urllib.parse import urlencode
from streamlit_webrtc import webrtc_streamer, AudioProcessorBase, WebRtcMode
import av
import streamlit.components.v1 as components
import base64
from audio_recorder_streamlit import audio_recorder
from groq import Groq
import google.generativeai as genai

# ========= C·∫•u h√¨nh =========
load_dotenv()
GROQ_API_KEY = os.getenv("GROQ_API_KEY")  # üîπ D√πng Groq API key
EMAIL_ADDRESS = os.getenv("EMAIL_ADDRESS")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD")
RESET_URL = os.getenv("RESET_URL")
RESET_TOKEN_PATH = "reset_tokens"
os.makedirs(RESET_TOKEN_PATH, exist_ok=True)
info = InMemoryAccountInfo()
b2_api = B2Api(info)
b2_api.authorize_account("production", os.getenv("B2_APPLICATION_KEY_ID"), os.getenv("B2_APPLICATION_KEY"))
bucket = b2_api.get_bucket_by_name(os.getenv("B2_BUCKET_NAME"))
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
GOOGLE_REDIRECT_URI = os.getenv("GOOGLE_REDIRECT_URI", "https://recapnote.up.railway.app")

# H√†m g·ªçi Groq API
def groq_chat(prompt, history=None, max_tokens=1000):
    """G·ªçi Groq API ƒë·ªÉ chat"""
    url = "https://api.groq.com/openai/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {GROQ_API_KEY}",
        "Content-Type": "application/json"
    }
    messages = []
    if history:
        messages.extend(history)
    messages.append({"role": "user", "content": prompt})
    payload = {
        "model": "llama3-70b-8192",
        "messages": messages,
        "max_tokens": max_tokens,
        "temperature": 0.7
    }
    res = requests.post(url, headers=headers, json=payload)
    res.raise_for_status()
    return res.json()["choices"][0]["message"]["content"].strip()

#================ Kh·ªüi t·∫°o session_state ================
if "recording" not in st.session_state:
    st.session_state.recording = False
if "start_time" not in st.session_state:
    st.session_state.start_time = 0
if "audio_saved" not in st.session_state:
    st.session_state.audio_saved = False
if "audio_url" not in st.session_state:
    st.session_state.audio_url = ""
if "logged_in" not in st.session_state:
    st.session_state.logged_in = False
if "profile" not in st.session_state:
    st.session_state.profile = None
    
#==================== ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u ============================
query_params = st.query_params
token = query_params.get("reset_token", [None])[0]
if token:
    try:
        with open(f"{RESET_TOKEN_PATH}/{token}.txt", "r") as f:
            username_token = f.read().strip()
    except:
        st.error("‚ùå M√£ x√°c th·ª±c kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.")
        st.stop()

    st.title("üîí ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u m·ªõi")
    new_pass = st.text_input("üîë M·∫≠t kh·∫©u m·ªõi", type="password")
    confirm = st.text_input("üîÅ X√°c nh·∫≠n m·∫≠t kh·∫©u", type="password")
    if st.button("C·∫≠p nh·∫≠t m·∫≠t kh·∫©u"):
        if new_pass != confirm:
            st.warning("‚ö†Ô∏è M·∫≠t kh·∫©u kh√¥ng kh·ªõp.")
        else:
            c.execute("UPDATE users SET password=? WHERE username=?", (new_pass, username_token))
            conn.commit()
            os.remove(f"{RESET_TOKEN_PATH}/{token}.txt")
            st.success("‚úÖ M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")
            st.stop()

#================= G·ª≠i reset email ====================
def send_reset_email(email, username):
    reset_token = secrets.token_urlsafe(24)
    reset_link = f"{RESET_URL}/?reset_token={reset_token}"
    with open(f"{RESET_TOKEN_PATH}/{reset_token}.txt", "w") as f:
        f.write(username)

    msg = MIMEText(f"""Xin ch√†o {username},

B·∫°n v·ª´a y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u cho t√†i kho·∫£n RecapNote.

üëâ Nh·∫•n v√†o ƒë∆∞·ªùng d·∫´n sau ƒë·ªÉ ƒë·ªïi m·∫≠t kh·∫©u:
{reset_link}

N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu, vui l√≤ng b·ªè qua email n√†y.

Tr√¢n tr·ªçng,
RecapNote""")

    msg["Subject"] = "üîê Kh√¥i ph·ª•c m·∫≠t kh·∫©u RecapNote"
    msg["From"] = EMAIL_ADDRESS
    msg["To"] = email

    try:
        with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
            server.login(EMAIL_ADDRESS, EMAIL_PASSWORD)
            server.send_message(msg)
        st.success("‚úÖ ƒê√£ g·ª≠i email kh√¥i ph·ª•c. Ki·ªÉm tra h·ªôp th∆∞!")
    except Exception as e:
        st.error(f"‚ùå G·ª≠i mail th·∫•t b·∫°i: {e}")

# ========= C∆° s·ªü d·ªØ li·ªáu =========
conn = sqlite3.connect("notes.db", check_same_thread=False)
c = conn.cursor()

# B·∫£ng users
c.execute('''CREATE TABLE IF NOT EXISTS users (
    username TEXT PRIMARY KEY, 
    password TEXT, 
    email TEXT
)''')

# B·∫£ng notes c√≥ json_url
c.execute('''CREATE TABLE IF NOT EXISTS notes (
    username TEXT, 
    title TEXT, 
    subject TEXT, 
    summary TEXT, 
    json_url TEXT, 
    timestamp TEXT
)''')

# N·∫øu DB c≈© thi·∫øu c·ªôt json_url th√¨ th√™m
try:
    c.execute("ALTER TABLE notes ADD COLUMN json_url TEXT")
except sqlite3.OperationalError:
    pass  # C·ªôt ƒë√£ t·ªìn t·∫°i

conn.commit()

# ========= Ti√™u ƒë·ªÅ v√† logo =========
st.set_page_config(page_title="RecapNote", layout="wide")
col1, col2 = st.columns([1, 5])
with col1:
    st.image("https://raw.githubusercontent.com/TrNghia16509/NoteBot/main/logo.png", width=150)
with col2:
    st.title("RecapNote - ·ª®ng d·ª•ng AI ghi nh·ªõ v√† t√≥m t·∫Øt vƒÉn b·∫£n")
    
# ================== Google OAuth Callback ==================
query_params = st.query_params
if "code" in query_params and not st.session_state.get("logged_in", False):
    code = query_params["code"]

    token_url = "https://oauth2.googleapis.com/token"
    data = {
        "code": code,
        "client_id": GOOGLE_CLIENT_ID,
        "client_secret": GOOGLE_CLIENT_SECRET,
        "redirect_uri": GOOGLE_REDIRECT_URI,
        "grant_type": "authorization_code"
    }
    token_res = requests.post(token_url, data=data)
    token_json = token_res.json()
    access_token = token_json.get("access_token")

    if access_token:
        user_info_res = requests.get(
            "https://www.googleapis.com/oauth2/v2/userinfo",
            headers={"Authorization": f"Bearer {access_token}"}
        )
        profile = user_info_res.json()

        st.session_state.logged_in = True
        st.session_state.profile = profile
        st.session_state.username = profile.get("email", "google_user")

        # N·∫øu user ch∆∞a c√≥ trong DB th√¨ th√™m
        c.execute("SELECT * FROM users WHERE username=?", (st.session_state.username,))
        if not c.fetchone():
            c.execute("INSERT INTO users VALUES (?, ?, ?)",
                      (st.session_state.username, b"", profile.get("email")))
            conn.commit()

        st.success(f"‚úÖ ƒêƒÉng nh·∫≠p Google th√†nh c√¥ng! Xin ch√†o {st.session_state.username}")
        st.rerun()
    else:
        st.error("‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c access token t·ª´ Google.")
        
# ================== Login / Register ==================
def login():
    st.subheader("üîê ƒêƒÉng nh·∫≠p")
    u = st.text_input("T√™n ƒëƒÉng nh·∫≠p ho·∫∑c email")
    p = st.text_input("M·∫≠t kh·∫©u", type="password")
    if st.button("ƒêƒÉng nh·∫≠p", key="login_btn"):
        row = c.execute("SELECT * FROM users WHERE (username=? OR email=?)", (u, u)).fetchone()
        if row and bcrypt.checkpw(p.encode('utf-8'), row[1]):
            st.session_state.logged_in = True
            st.session_state.username = row[0]
            st.success("‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!")
            st.rerun()
        else:
            st.error("Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u.")

    # N√∫t ƒëƒÉng nh·∫≠p Google
    google_auth_url = "https://accounts.google.com/o/oauth2/v2/auth"
    params = {
    "client_id": GOOGLE_CLIENT_ID,
    "redirect_uri": GOOGLE_REDIRECT_URI,
    "response_type": "code",
    "scope": "openid email profile",
    "access_type": "offline",
    "prompt": "consent"
    }
    auth_link = f"{google_auth_url}?{urlencode(params)}"

    # CSS ƒë·ªÉ style gi·ªëng st.button
    st.markdown(
        f"""
        <a href="{auth_link}" target="_self">
            <button style="
                background-color: #2e7efb;
                color: white;
                padding: 0.5rem 1rem;
                border: none;
                border-radius: 0.25rem;
                font-size: 1rem;
                cursor: pointer;
            ">
                ƒêƒÉng nh·∫≠p v·ªõi Google
            </button>
        </a>
        """,
        unsafe_allow_html=True
    )

    # Qu√™n m·∫≠t kh·∫©u
    if st.button("Qu√™n m·∫≠t kh·∫©u?", key="forgot_btn"):
        email_reset = st.text_input("üìß Nh·∫≠p email ƒë√£ ƒëƒÉng k√Ω")
        if email_reset:
            row = c.execute("SELECT username FROM users WHERE email=?", (email_reset,)).fetchone()
            if row:
                send_reset_email(email_reset, row[0])
            else:
                st.error("‚ùå Kh√¥ng t√¨m th·∫•y email trong h·ªá th·ªëng.")

def register():
    st.subheader("üÜï ƒêƒÉng k√Ω")
    new_user = st.text_input("T√™n ƒëƒÉng nh·∫≠p m·ªõi")
    email = st.text_input("Email")
    pw1 = st.text_input("M·∫≠t kh·∫©u", type="password")
    pw2 = st.text_input("X√°c nh·∫≠n m·∫≠t kh·∫©u", type="password")
    if st.button("ƒêƒÉng k√Ω", key="register_btn"):
        if pw1 != pw2:
            st.warning("‚ùå M·∫≠t kh·∫©u kh√¥ng kh·ªõp.")
        else:
            hashed_pw = bcrypt.hashpw(pw1.encode('utf-8'), bcrypt.gensalt())
            c.execute("INSERT INTO users VALUES (?, ?, ?)", (new_user, hashed_pw, email))
            conn.commit()
            st.success("‚úÖ ƒêƒÉng k√Ω th√†nh c√¥ng. H√£y ƒëƒÉng nh·∫≠p.")

# ================== Sidebar ==================
with st.sidebar:
    st.markdown("## üîë T√†i kho·∫£n")
    if st.session_state.get("logged_in", False):
        st.success(f"üëã Xin ch√†o, **{st.session_state.username}**")
        if st.button("üö™ ƒêƒÉng xu·∫•t", key="logout_btn"):
            st.session_state.logged_in = False
            st.session_state.profile = None
            st.rerun()
    else:
        menu = st.radio("Ch·ªçn ch·ª©c nƒÉng", ["ƒêƒÉng nh·∫≠p", "ƒêƒÉng k√Ω"])
        if menu == "ƒêƒÉng nh·∫≠p":
            login()
        else:
            register()
            
# ========= H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng =========
with st.expander("üìò H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng (Chi ti·∫øt)"):
    st.markdown("""
## 1. T·∫£i file ho·∫∑c ghi √¢m tr·ª±c ti·∫øp
- ·ªû **g√≥c tr√™n c√πng ho·∫∑c khu v·ª±c ch√≠nh c·ªßa trang**, b·∫°n s·∫Ω th·∫•y n√∫t:
  - **üìÇ "Ch·ªçn file"** ho·∫∑c **"T·∫£i file"** ‚Üí b·∫•m ƒë·ªÉ ch·ªçn t·ªáp t·ª´ m√°y t√≠nh.
  - **üé§ "Ghi √¢m"** ‚Üí b·∫•m ƒë·ªÉ ghi √¢m tr·ª±c ti·∫øp b·∫±ng micro (tr√¨nh duy·ªát s·∫Ω y√™u c·∫ßu c·∫•p quy·ªÅn micro).
- H·ªó tr·ª£ ƒë·ªãnh d·∫°ng:
  - √Çm thanh: `.mp3`, `.wav`
  - T√†i li·ªáu: `.pdf`, `.docx`
- M·∫πo: N·∫øu file qu√° l·ªõn, h√£y chia th√†nh nhi·ªÅu file nh·ªè ƒë·ªÉ x·ª≠ l√Ω nhanh h∆°n.

## 2. Ch·ªçn ng√¥n ng·ªØ
- Ngay d∆∞·ªõi √¥ t·∫£i file, b·∫°n s·∫Ω th·∫•y **menu ch·ªçn ng√¥n ng·ªØ**:
  - Ch·ªçn **ng√¥n ng·ªØ ch√≠nh** c·ªßa n·ªôi dung (VD: Ti·∫øng Vi·ªát, Ti·∫øng Anh‚Ä¶).
  - N·∫øu kh√¥ng ch·∫Øc ‚Üí ch·ªçn **T·ª± ƒë·ªông nh·∫≠n di·ªán (auto)**.
- Vi·ªác ch·ªçn ƒë√∫ng ng√¥n ng·ªØ gi√∫p **chuy·ªÉn ƒë·ªïi vƒÉn b·∫£n ch√≠nh x√°c h∆°n**.

## 3. X·ª≠ l√Ω n·ªôi dung
- Sau khi t·∫£i file ho·∫∑c ghi √¢m, b·∫•m **"X·ª≠ l√Ω" / "T√≥m t·∫Øt"**.
- H·ªá th·ªëng s·∫Ω:
  1. **Chuy·ªÉn √¢m thanh ho·∫∑c t√†i li·ªáu th√†nh vƒÉn b·∫£n**.
  2. **Nh·∫≠n di·ªán ch·ªß ƒë·ªÅ ch√≠nh**.
  3. **T·∫°o b·∫£n t√≥m t·∫Øt ng·∫Øn g·ªçn, ƒë·∫ßy ƒë·ªß √Ω**.
- K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ngay tr√™n m√†n h√¨nh.

## 4. L∆∞u v√† h·ªèi ƒë√°p
- B·∫°n c√≥ th·ªÉ:
  - **L∆∞u ghi ch√∫** (n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p).
  - **Ghi ch√∫ t·∫°m th·ªùi** (n·∫øu ch∆∞a ƒëƒÉng nh·∫≠p ‚Äî s·∫Ω m·∫•t khi ƒë√≥ng trang).
  - **H·ªèi th√™m qua Chatbox th√¥ng minh** v·ªÅ n·ªôi dung t·ªáp v·ª´a x·ª≠ l√Ω.

## 5. M·ªôt s·ªë l∆∞u √Ω
- **Dung l∆∞·ª£ng file**: N√™n < 100MB ƒë·ªÉ x·ª≠ l√Ω nhanh.
- Hi·ªán ch∆∞a kh·∫£ d·ª•ng cho file ch·ª©a c√°c k√≠ t·ª± ƒë·∫∑c bi·ªát (k√≠ t·ª± to√°n h·ªçc,.....)
- **K·∫øt n·ªëi m·∫°ng ·ªïn ƒë·ªãnh** khi t·∫£i file/ghi √¢m.
- N·∫øu g·∫∑p l·ªói "qu√° gi·ªõi h·∫°n API", h√£y th·ª≠ l·∫°i sau v√†i ph√∫t.
- D·ªØ li·ªáu c·ªßa b·∫°n ƒë∆∞·ª£c **b·∫£o m·∫≠t**, ch·ªâ d√πng ƒë·ªÉ x·ª≠ l√Ω n·ªôi dung.

---
üí° **M·∫πo s·ª≠ d·ª•ng nhanh**:  
üìÇ B·∫•m "Ch·ªçn file" ‚Üí ch·ªçn t·ªáp ‚Üí ch·ªçn ng√¥n ng·ªØ ‚Üí b·∫•m "X·ª≠ l√Ω" ‚Üí ch·ªù t√≥m t·∫Øt ‚Üí h·ªèi ƒë√°p ho·∫∑c l∆∞u ghi ch√∫.
""")

# ========= Ch·ªçn ng√¥n ng·ªØ =========
# Ch·ªçn ng√¥n ng·ªØ
LANGUAGE_MAP = {
    "Auto Detect": "auto",
    "Vietnamese": "vi",
    "English": "en",
    "Japanese": "ja",
    "Korean": "ko",
    "French": "fr",
    "Chinese": "zh"
}

selected_lang_name = st.selectbox("Select language", list(LANGUAGE_MAP.keys()), index=1)
selected_lang_code = LANGUAGE_MAP[selected_lang_name]

# ========== Ghi √¢m (frontend) ==========
st.title("üéô Ghi √¢m")
if "audio_bytes" not in st.session_state:
    st.session_state.audio_bytes = None

if st.session_state.audio_bytes is None:
    audio_bytes = audio_recorder(
        pause_threshold=2.0,
        sample_rate=44100,
        text="Nh·∫•n ƒë·ªÉ ghi √¢m v√† nh·∫•n l·∫°i l·∫ßn n·ªØa ƒë·ªÉ d·ª´ng"
    )
    if audio_bytes:
        st.session_state.audio_bytes = audio_bytes
else:
    st.audio(st.session_state.audio_bytes, format="audio/wav")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üì§ X·ª≠ l√Ω"):
            with st.spinner("ƒêang g·ª≠i file..."):
                files = {
                    "file": ("recording.wav", st.session_state.audio_bytes, "audio/wav")
                }
                data = {
                    "language_code": selected_lang_code
                }
                try:
                    res = requests.post(
                        "https://flask-recapnote.onrender.com/process_file",
                        files=files,
                        data=data,
                        timeout=120
                    )
                    if res.ok:
                        result = res.json()
                        st.success("‚úÖ K·∫øt qu·∫£")
                        st.write("**Ch·ªß ƒë·ªÅ:**", result["subject"])
                        st.write("**T√≥m t·∫Øt:**", result["summary"])
                    else:
                        st.error(f"L·ªói {res.status_code}: {res.text}")
                except Exception as e:
                    st.error(f"L·ªói k·∫øt n·ªëi: {e}")
    with col2:
        if st.button("üóë X√≥a b·∫£n ghi"):
            st.session_state.audio_bytes = None
            st.rerun()

# ==================== T·∫£i file =====================
API_URL = os.getenv("FLASK_API_URL", "https://flask-recapnote.onrender.com")

if "username" not in st.session_state:
    st.session_state.username = ""

st.header("üì§ T·∫£i file ƒë·ªÉ x·ª≠ l√Ω")
file = st.file_uploader("Ch·ªçn file (.mp3, .wav, .pdf, .docx)", type=["mp3", "wav", "pdf", "docx"])

if file:
    with st.spinner("‚è≥ ƒêang x·ª≠ l√Ω..."):
        res = requests.post(
            f"{API_URL}/process_file",
            files={"file": (file.name, file, file.type)},
            data={"language_code": selected_lang_code},
            timeout=None,
            stream=True
        )

    if res.status_code == 200:
        data = res.json()
        subject = data["subject"]
        summary = data["summary"]
        full_text = data["full_text"]

        st.subheader("üìå Ch·ªß ƒë·ªÅ")
        st.write(subject)
        st.subheader("üìö T√≥m t·∫Øt")
        st.write(summary)
        st.subheader("üìÑ N·ªôi dung")
        st.text_area("", full_text, height=300, label_visibility="collapsed")

        # === Chatbot theo t·ª´ng file ===
        GEMINI_API_KEY = os.getenv("GOOGLE_API_KEY")
        genai.configure(api_key=GEMINI_API_KEY)
        gemini_model = genai.GenerativeModel("gemini-1.5-flash")
        file_key = f"chat_{file.name}"
        if file_key not in st.session_state:
            st.session_state[file_key] = []

        st.markdown("### ü§ñ H·ªèi g√¨ th√™m v·ªÅ n·ªôi dung?")
        for msg in st.session_state[file_key]:
            st.chat_message(msg["role"]).write(msg["content"])

        q = st.chat_input("Nh·∫≠p c√¢u h·ªèi...")
        if q:
            st.chat_message("user").write(q)

            # G·ª≠i cho Gemini, ch·ªâ d√πng summary ƒë·ªÉ tr√°nh l·ªói 413
            context_prompt = f"""
            B·∫°n l√† tr·ª£ l√Ω AI, h√£y tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n b·∫£n t√≥m t·∫Øt sau:
            --- T√≥m t·∫Øt ---
            {summary}
            """

            ai = gemini_model.start_chat(history=[
                {"role": "user", "parts": [context_prompt]}
            ])
            r = ai.send_message(q)

            st.chat_message("assistant").write(r.text)
            st.session_state[file_key].append({"role": "user", "content": q})
            st.session_state[file_key].append({"role": "assistant", "content": r.text})
        # === L∆∞u ghi ch√∫ n·∫øu ƒë√£ ƒëƒÉng nh·∫≠p ===
        if st.session_state.logged_in:
            if st.button("üíæ L∆∞u ghi ch√∫"):
                json_file_name = data["json_url"].split("/")[-2] + "/" + data["json_url"].split("/")[-1]
                c.execute("INSERT INTO notes VALUES (?, ?, ?, ?, ?, ?)", (
                    st.session_state.username,
                    subject,
                    subject,
                    summary,
                    json_file_name,
                    datetime.now().isoformat()
                ))
                conn.commit()
                st.success("ƒê√£ l∆∞u!")
        else:
            st.info("üîí Ghi ch√∫ t·∫°m th·ªùi - h√£y ƒëƒÉng nh·∫≠p ƒë·ªÉ l∆∞u vƒ©nh vi·ªÖn")
    else:
        st.error(f"L·ªói: {res.text}")
        
# ========= Hi·ªÉn th·ªã ghi ch√∫ =========
if st.session_state.logged_in:
    st.subheader("üìÇ Ghi ch√∫ ƒë√£ l∆∞u")
    rows = c.execute(
        "SELECT title, summary, timestamp, json_url FROM notes WHERE username=?",
        (st.session_state.username,)
    ).fetchall()

    for r in rows:
        with st.expander(f"üìù {r[0]} ({r[2][:10]})"):
            st.markdown(f"**T√≥m t·∫Øt:** {r[1]}")
            if r[3]:
                if st.button("üì• Xem chi ti·∫øt", key=f"view_{r[0]}_{r[2]}"):
                    try:
                        # G·ªçi backend xin signed URL m·ªõi cho JSON
                        resp = requests.get(f"{API_URL}/get_note_json", params={"json_file": r[3]})
                        if resp.status_code == 200:
                            json_url = resp.json()["signed_url"]
                            json_data = requests.get(json_url).json()
                            st.text_area("üìÑ N·ªôi dung", json_data.get("full_text", ""), height=300)
                            if json_data.get("file_url"):
                                st.markdown(f"[üìÇ T·∫£i file g·ªëc]({json_data['file_url']})")
                        else:
                            st.error("Kh√¥ng l·∫•y ƒë∆∞·ª£c link JSON t·ª´ backend.")
                    except Exception as e:
                        st.error(f"‚ùå L·ªói t·∫£i file JSON: {e}")
            else:
                st.warning("‚ö†Ô∏è Ghi ch√∫ n√†y ch∆∞a c√≥ file JSON.")
# ============ Ch·∫°y ==================
port = int(os.environ.get("PORT", 8501))

